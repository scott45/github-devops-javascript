name: Prepare and Publish Release
on:
  push:
    branches:
      - main
jobs:
  release:
    if: github.actor != 'dependabot[bot]' && github.actor != 'dependabot-preview[bot]'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # full history
      - name: Install GH CLI
        run: |
          sudo apt update && sudo apt install curl -y
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list
          sudo apt update && sudo apt install gh -y
          gh auth login --with-token <<< ${{ secrets.DEMO_GITHUB_TOKEN }}

      - name: Generate Release and Publish (latest tag by time)
        env:
          GH_TOKEN: ${{ secrets.DEMO_GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.DEMO_GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Ensure tags are present locally
          git fetch --tags --force

          # 1) Get latest tag by creation time (not ancestry). Fallback to v1.0.0
          RAW_LAST_TAG="$(git for-each-ref --sort=-creatordate --format '%(refname:short)' refs/tags | head -n1 || true)"
          if [ -z "${RAW_LAST_TAG:-}" ]; then
            LAST_TAG="v1.0.0"
            TAG_START_DATE=""   # no previous tag; we'll treat notes as initial
          else
            LAST_TAG="$RAW_LAST_TAG"
          fi

          # Normalize to vX.Y.Z form for parsing
          case "$LAST_TAG" in
            v*) ;;  # already has v
            *) LAST_TAG="v$LAST_TAG" ;;
          esac
          echo "Last tag (by time): $LAST_TAG"

          # 1a) Determine the timestamp of the last tag (works for annotated/lightweight)
          # Try taggerdate; if absent (lightweight), use the commit date of the tagged object.
          TAG_START_DATE="$(git for-each-ref --format='%(taggerdate:iso8601)' "refs/tags/${LAST_TAG#v}" | head -n1 || true)"
          if [ -z "${TAG_START_DATE:-}" ]; then
            # For lightweight tags, resolve to the tagged object and use its committer date
            TAG_COMMIT="$(git rev-list -n 1 "$LAST_TAG" 2>/dev/null || true)"
            if [ -n "${TAG_COMMIT:-}" ]; then
              TAG_START_DATE="$(git show -s --format=%cI "$TAG_COMMIT")"
            fi
          fi
          echo "Last tag date (iso8601): ${TAG_START_DATE:-<none>}"

          # 2) Parse current version numbers from LAST_TAG (vX.Y.Z)
          CURRENT_MAJOR="$(echo "$LAST_TAG" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\1/p')"
          CURRENT_MINOR="$(echo "$LAST_TAG" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\2/p')"
          CURRENT_PATCH="$(echo "$LAST_TAG" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\3/p')"

          if [ -z "$CURRENT_MAJOR" ] || [ -z "$CURRENT_MINOR" ] || [ -z "$CURRENT_PATCH" ]; then
            echo "LAST_TAG not in vX.Y.Z format. Aborting."
            exit 1
          fi

          NEW_MAJOR="$CURRENT_MAJOR"
          NEW_MINOR="$CURRENT_MINOR"
          NEW_PATCH="$CURRENT_PATCH"

          # 3) Get merged PR title associated with this push commit (if any)
          PR_TITLE="$(gh api \
            -H "Accept: application/vnd.github+json" \
            "repos/${{ github.repository }}/commits/${{ github.sha }}/pulls" \
            --jq '.[0].title' || true)"
          echo "PR title: ${PR_TITLE:-<none>}"

          # 4) Decide bump via Conventional Commits
          BUMP="patch"
          case "${PR_TITLE:-}" in
            feat!:*) BUMP="major" ;;
            feat:*)  BUMP="minor" ;;
            fix:*|refactor:*|chore:*|docs:*|test:*) BUMP="patch" ;;
            *) BUMP="patch" ;;
          esac
          echo "Bump type: $BUMP"

          # 5) Compute new version
          if [ "$BUMP" = "major" ]; then
            NEW_MAJOR=$((CURRENT_MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
          elif [ "$BUMP" = "minor" ]; then
            NEW_MINOR=$((CURRENT_MINOR + 1))
            NEW_PATCH=0
          else
            NEW_PATCH=$((CURRENT_PATCH + 1))
          fi

          TAG="v${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"

          # 6) Ensure tag is unique
          while git show-ref --tags --verify --quiet "refs/tags/$TAG"; do
            echo "Tag $TAG already exists, incrementing patchâ€¦"
            NEW_PATCH=$((NEW_PATCH + 1))
            TAG="v${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
          done
          echo "New tag: $TAG"

          # 7) Release notes:
          #    If we have a prior tag date, collect commits since that timestamp (first-parent).
          #    Otherwise (no prior tag), mark as initial release.
          if [ -n "${TAG_START_DATE:-}" ]; then
            NOTES="$(git log --since="$TAG_START_DATE" --first-parent --pretty=format:"- %s" | \
              grep -E '^(feat|fix|chore|docs|test|refactor):' || true)"
          else
            NOTES=""
          fi
          if [ -z "$NOTES" ]; then
            NOTES="Initial release"
          fi
          echo "Release notes:"
          echo "$NOTES"

          # 8) Create tag & publish release
          git tag "$TAG"
          git push origin "$TAG"
          gh release create "$TAG" \
            --title "Release ${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}" \
            --notes "$NOTES"
