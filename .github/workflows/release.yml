name: Prepare and Publish Release
on:
  push:
    branches:
      - main
jobs:
  release:
    if: github.actor != 'dependabot[bot]' && github.actor != 'dependabot-preview[bot]'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for last tag and notes
      - name: Install GH CLI
        run: |
          sudo apt update && sudo apt install curl -y
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list
          sudo apt update && sudo apt install gh -y
          gh auth login --with-token <<< ${{ secrets.DEMO_GITHUB_TOKEN }}
      - name: Generate Release and Publish
        env:
          GH_TOKEN: ${{ secrets.DEMO_GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.DEMO_GITHUB_TOKEN }}  # gh uses this too
        run: |
          set -euo pipefail

          # 1) Get last tag or default
          LAST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || echo 'v1.0.0')"
          echo "Last tag: $LAST_TAG"

          # 2) Parse current version numbers from LAST_TAG (vX.Y.Z)
          CURRENT_MAJOR="$(echo "$LAST_TAG" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\1/p')"
          CURRENT_MINOR="$(echo "$LAST_TAG" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\2/p')"
          CURRENT_PATCH="$(echo "$LAST_TAG" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\3/p')"

          if [ -z "$CURRENT_MAJOR" ] || [ -z "$CURRENT_MINOR" ] || [ -z "$CURRENT_PATCH" ]; then
            echo "LAST_TAG not in vX.Y.Z format. Aborting."
            exit 1
          fi

          # Initialize new version with current (we'll increment below)
          NEW_MAJOR="$CURRENT_MAJOR"
          NEW_MINOR="$CURRENT_MINOR"
          NEW_PATCH="$CURRENT_PATCH"

          # 3) Get merged PR title for this push (to main)
          #    Use the GH API to find the PR(s) associated with this commit SHA.
          #    The endpoint returns an array; take the first one.
          PR_TITLE="$(gh api \
            -H "Accept: application/vnd.github+json" \
            "repos/${{ github.repository }}/commits/${{ github.sha }}/pulls" \
            --jq '.[0].title' || true)"

          echo "PR title: ${PR_TITLE:-<none>}"

          # 4) Decide bump based on PR title (Conventional Commits)
          #    feat!: -> major, feat: -> minor, otherwise -> patch
          BUMP="patch"
          case "${PR_TITLE:-}" in
            feat!:*)
              BUMP="major"
              ;;
            feat:*)
              BUMP="minor"
              ;;
            fix:*|refactor:*|chore:*|docs:*|test:*)
              BUMP="patch"
              ;;
            *)
              # default to patch if unknown or PR_TITLE empty
              BUMP="patch"
              ;;
          esac
          echo "Bump type: $BUMP"

          # 5) Compute new version
          if [ "$BUMP" = "major" ]; then
            NEW_MAJOR=$((CURRENT_MAJOR + 1))
            NEW_MINOR=0
            NEW_PATCH=0
          elif [ "$BUMP" = "minor" ]; then
            NEW_MINOR=$((CURRENT_MINOR + 1))
            NEW_PATCH=0
          else
            NEW_PATCH=$((CURRENT_PATCH + 1))
          fi

          TAG="v${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"

          # 6) Ensure tag is new; if exists, bump patch until free
          while git rev-parse "$TAG" >/dev/null 2>&1; do
            echo "Tag $TAG already exists, incrementing patchâ€¦"
            NEW_PATCH=$((NEW_PATCH + 1))
            TAG="v${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"
          done

          echo "New tag: $TAG"

          # 7) Release notes from commits since LAST_TAG on first-parent (PR merge history)
          NOTES="$(git log "${LAST_TAG}..HEAD" --first-parent --pretty=format:"- %s" | \
            grep -E '^(feat|fix|chore|docs|test|refactor):' || true)"
          if [ -z "$NOTES" ]; then
            NOTES="Initial release"
          fi
          echo "Release notes:"
          echo "$NOTES"

          # 8) Create tag & publish release
          git tag "$TAG"
          git push origin "$TAG"

          gh release create "$TAG" \
            --title "Release ${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}" \
            --notes "$NOTES"
