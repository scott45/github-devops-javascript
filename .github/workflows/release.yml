name: Prepare and Publish Release
on:
  push:
    branches:
      - main
jobs:
  release:
    if: github.actor != 'dependabot[bot]' && github.actor != 'dependabot-preview[bot]'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # full history
      - name: Install GH CLI
        run: |
          sudo apt update && sudo apt install curl -y
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list
          sudo apt update && sudo apt install gh -y
          gh auth login --with-token <<< ${{ secrets.DEMO_GITHUB_TOKEN }}

      - name: Generate Release and Publish (latest tag by time, auto notes)
        env:
          GH_TOKEN: ${{ secrets.DEMO_GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.DEMO_GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Ensure tags are present locally
          git fetch --tags --force

          # Get newest and previous tags by creation time (not ancestry)
          mapfile -t TAGS < <(git for-each-ref --sort=-creatordate --format '%(refname:short)' refs/tags)
          RAW_LAST_TAG="${TAGS[0]:-}"
          RAW_PREV_TAG="${TAGS[1]:-}"

          if [ -z "$RAW_LAST_TAG" ]; then
            # No tags at all yet: start from v1.0.0
            LAST_TAG_NORM="v1.0.0"
          else
            # Normalize newest tag to vX.Y.Z for version parsing
            case "$RAW_LAST_TAG" in v*) LAST_TAG_NORM="$RAW_LAST_TAG" ;; *) LAST_TAG_NORM="v$RAW_LAST_TAG" ;; esac
          fi

          echo "Newest tag by time: ${RAW_LAST_TAG:-<none>}"
          echo "Previous tag by time: ${RAW_PREV_TAG:-<none>}"

          # Parse current version numbers from LAST_TAG_NORM (vX.Y.Z)
          CUR_MAJ="$(echo "$LAST_TAG_NORM" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\1/p')"
          CUR_MIN="$(echo "$LAST_TAG_NORM" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\2/p')"
          CUR_PAT="$(echo "$LAST_TAG_NORM" | sed -n 's/^v\([0-9]\+\)\.\([0-9]\+\)\.\([0-9]\+\)$/\3/p')"
          if [ -z "$CUR_MAJ" ] || [ -z "$CUR_MIN" ] || [ -z "$CUR_PAT" ]; then
            echo "Last tag not in vX.Y.Z format. Aborting."
            exit 1
          fi

          NEW_MAJ="$CUR_MAJ"; NEW_MIN="$CUR_MIN"; NEW_PAT="$CUR_PAT"

          # Determine bump from merged PR title for this push (if any)
          PR_TITLE="$(gh api -H "Accept: application/vnd.github+json" \
            "repos/${{ github.repository }}/commits/${{ github.sha }}/pulls" \
            --jq '.[0].title' || true)"
          echo "PR title: ${PR_TITLE:-<none>}"

          BUMP="patch"
          case "${PR_TITLE:-}" in
            feat!:*) BUMP="major" ;;
            feat:*)  BUMP="minor" ;;
            fix:*|refactor:*|chore:*|docs:*|test:*) BUMP="patch" ;;
            *)       BUMP="patch" ;;
          esac
          echo "Bump type: $BUMP"

          if [ "$BUMP" = "major" ]; then
            NEW_MAJ=$((CUR_MAJ + 1)); NEW_MIN=0; NEW_PAT=0
          elif [ "$BUMP" = "minor" ]; then
            NEW_MIN=$((CUR_MIN + 1)); NEW_PAT=0
          else
            NEW_PAT=$((CUR_PAT + 1))
          fi

          TAG="v${NEW_MAJ}.${NEW_MIN}.${NEW_PAT}"

          # Ensure tag uniqueness
          while git show-ref --tags --verify --quiet "refs/tags/$TAG"; do
            echo "Tag $TAG exists, bumping patchâ€¦"
            NEW_PAT=$((NEW_PAT + 1))
            TAG="v${NEW_MAJ}.${NEW_MIN}.${NEW_PAT}"
          done
          echo "New tag: $TAG"

          # Create and push the tag
          git tag "$TAG"
          git push origin "$TAG"

          # Create the release with GitHub's auto-generated notes.
          # If we have a previous tag by time, use it as the notes start.
          if [ -n "${RAW_PREV_TAG:-}" ]; then
            gh release create "$TAG" \
              --title "Release ${NEW_MAJ}.${NEW_MIN}.${NEW_PAT}" \
              --generate-notes \
              --notes-start-tag "$RAW_PREV_TAG"
          else
            gh release create "$TAG" \
              --title "Release ${NEW_MAJ}.${NEW_MIN}.${NEW_PAT}" \
              --generate-notes
          fi
